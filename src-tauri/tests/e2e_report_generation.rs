//! E2E Integration Test: Create Incident â†’ Generate Report
//! Tests the complete flow of creating an incident and generating a report

#[cfg(test)]
mod tests {
    use sqlx::sqlite::SqlitePool;
    use uuid::Uuid;

    /// Helper: Create test database with migrations
    async fn setup_test_db() -> SqlitePool {
        let database_url = "sqlite::memory:";
        let pool = SqlitePool::connect(database_url)
            .await
            .expect("Failed to create test database");

        // Run migrations
        sqlx::migrate!("src/db/sql")
            .run(&pool)
            .await
            .expect("Failed to run migrations");

        pool
    }

    /// Helper: Create a service for testing
    async fn create_test_service(db: &SqlitePool) -> String {
        let id = Uuid::new_v4().to_string();

        sqlx::query(
            r#"
            INSERT INTO services (id, name, description, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?)
            "#,
        )
        .bind(&id)
        .bind("Report Test Service")
        .bind("Service for report generation tests")
        .bind("2025-01-15T10:00:00Z")
        .bind("2025-01-15T10:00:00Z")
        .execute(db)
        .await
        .expect("Failed to insert service");

        id
    }

    #[tokio::test]
    async fn test_create_incident_then_generate_report() {
        let db = setup_test_db().await;
        let service_id = create_test_service(&db).await;

        // Step 1: Create incident
        let incident_id = Uuid::new_v4().to_string();
        sqlx::query(
            r#"
            INSERT INTO incidents (
                id, title, service_id, severity, impact, status,
                root_cause, resolution,
                started_at, detected_at, resolved_at, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            "#,
        )
        .bind(&incident_id)
        .bind("API Timeout Issue")
        .bind(&service_id)
        .bind("P1")
        .bind("high")
        .bind("resolved")
        .bind("Upstream service experiencing high latency")
        .bind("Increased timeout threshold and added circuit breaker")
        .bind("2025-01-15T10:00:00Z")
        .bind("2025-01-15T10:05:00Z")
        .bind("2025-01-15T11:00:00Z")
        .bind("2025-01-15T10:00:00Z")
        .bind("2025-01-15T11:00:00Z")
        .execute(&db)
        .await
        .expect("Failed to insert incident");

        // Step 2: Verify incident was created for report
        let row = sqlx::query(
            "SELECT id, title, severity, status, root_cause FROM incidents WHERE id = ?",
        )
        .bind(&incident_id)
        .fetch_one(&db)
        .await
        .expect("Incident not found for report generation");

        assert_eq!(row.get::<String, _>("title"), "API Timeout Issue");
        assert_eq!(row.get::<String, _>("severity"), "P1");
        assert_eq!(row.get::<String, _>("status"), "resolved");
        assert!(row.get::<Option<String>, _>("root_cause").is_some());

        // Step 3: Verify report can be generated by checking incident has required fields
        let has_incident_data = row.get::<Option<String>, _>("root_cause").is_some();
        assert!(has_incident_data, "Incident must have root cause for report");
    }

    #[tokio::test]
    async fn test_report_with_multiple_incidents() {
        let db = setup_test_db().await;
        let service_id = create_test_service(&db).await;

        // Create quarter config (needed for report generation)
        let quarter_id = Uuid::new_v4().to_string();
        sqlx::query(
            r#"
            INSERT INTO quarter_config (id, fiscal_year, quarter_number, start_date, end_date, created_at)
            VALUES (?, ?, ?, ?, ?, ?)
            "#,
        )
        .bind(&quarter_id)
        .bind(2025)
        .bind(1)
        .bind("2025-01-01")
        .bind("2025-03-31")
        .bind("2025-01-15T10:00:00Z")
        .execute(&db)
        .await
        .expect("Failed to insert quarter");

        // Create multiple incidents for report
        for i in 0..5 {
            let incident_id = Uuid::new_v4().to_string();
            let severity = match i {
                0 => "P0",
                1 => "P1",
                _ => "P2",
            };

            sqlx::query(
                r#"
                INSERT INTO incidents (
                    id, title, service_id, severity, impact, status,
                    started_at, detected_at, resolved_at, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                "#,
            )
            .bind(&incident_id)
            .bind(format!("Report Incident {}", i))
            .bind(&service_id)
            .bind(severity)
            .bind("high")
            .bind("resolved")
            .bind("2025-01-15T10:00:00Z")
            .bind("2025-01-15T10:05:00Z")
            .bind("2025-01-15T11:00:00Z")
            .bind("2025-01-15T10:00:00Z")
            .bind("2025-01-15T11:00:00Z")
            .execute(&db)
            .await
            .expect("Failed to insert incident");
        }

        // Verify we can count incidents for report
        let count_row = sqlx::query("SELECT COUNT(*) as total FROM incidents WHERE status = ?")
            .bind("resolved")
            .fetch_one(&db)
            .await
            .expect("Failed to count incidents");

        let total: i64 = count_row.get("total");
        assert_eq!(total, 5, "Should have 5 resolved incidents for report");
    }

    #[tokio::test]
    async fn test_report_can_access_incident_details() {
        let db = setup_test_db().await;
        let service_id = create_test_service(&db).await;

        let incident_id = Uuid::new_v4().to_string();
        let detailed_description = "This was a major outage affecting 5000+ users. The root cause was identified as a memory leak in the connection pool handler. Mitigation steps included restarting services and implementing improved monitoring.";

        sqlx::query(
            r#"
            INSERT INTO incidents (
                id, title, service_id, severity, impact, status,
                description, root_cause,
                started_at, detected_at, resolved_at, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            "#,
        )
        .bind(&incident_id)
        .bind("Major Outage")
        .bind(&service_id)
        .bind("P0")
        .bind("critical")
        .bind("resolved")
        .bind("Production database became unavailable")
        .bind(detailed_description)
        .bind("2025-01-15T10:00:00Z")
        .bind("2025-01-15T10:05:00Z")
        .bind("2025-01-15T12:00:00Z")
        .bind("2025-01-15T10:00:00Z")
        .bind("2025-01-15T12:00:00Z")
        .execute(&db)
        .await
        .expect("Failed to insert detailed incident");

        // Verify report can access all details
        let row = sqlx::query(
            "SELECT title, severity, description, root_cause FROM incidents WHERE id = ?",
        )
        .bind(&incident_id)
        .fetch_one(&db)
        .await
        .expect("Incident not found");

        let title: String = row.get("title");
        let description: Option<String> = row.get("description");
        let root_cause: Option<String> = row.get("root_cause");

        assert_eq!(title, "Major Outage");
        assert!(description.is_some());
        assert!(root_cause.is_some());
        assert!(description.unwrap().len() > 0);
        assert!(root_cause.unwrap().len() > 0);
    }
}
